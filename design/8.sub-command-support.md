# Sub Command (Nested Command) Support

Related: https://github.com/kazupon/gunshi/issues/493

## Problem

Currently, gunshi supports only **single-level** sub-commands (e.g., `cli-name command1`).
Nested sub-commands like `git remote add` are not supported.

### Current Limitations

- `cliCore()`'s `getSubCommand()` only extracts the first positional argument as the sub-command name (`core.ts:224-232`)
- `resolveCommand()` performs only a single-level lookup from the `subCommands` Map (`core.ts:244-302`)
- `CommandContext`'s `callMode` is limited to three values: `'entry' | 'subCommand' | 'unexpected'` (`types.ts:346`)
- The renderer's `renderCommandsSection()` displays immediate sub-commands in a flat list (`usage.ts`)

### Considerations

- Usage rendering via `@gunshi/plugin-renderer`
- Command lazy loading
- Compatibility with other plugins such as `@gunshi/plugin-i18n`
- Performance

---

## Proposal A: Command Tree (Add subCommands to the Command interface)

### Overview

Add a `subCommands` property directly to the `Command` interface to naturally represent tree structures.

```typescript
// Extension of the Command interface
interface Command<G> {
  name?: string
  description?: string
  args?: ExtractArgs<G>
  run?: CommandRunner<G>
  subCommands?: Record<string, SubCommandable> | Map<string, SubCommandable>
  // ...existing properties
}
```

### User API

```typescript
const addCommand = define({
  name: 'add',
  description: 'Add a remote',
  args: { url: { type: 'string', required: true } },
  run: ctx => console.log(`Adding remote: ${ctx.values.url}`)
})

const removeCommand = define({
  name: 'remove',
  description: 'Remove a remote',
  args: { name: { type: 'string', required: true } },
  run: ctx => console.log(`Removing remote: ${ctx.values.name}`)
})

const remoteCommand = define({
  name: 'remote',
  description: 'Manage remotes',
  subCommands: { add: addCommand, remove: removeCommand },
  run: () => console.log('Use: git remote add|remove')
})

await cli(process.argv.slice(2), entry, {
  name: 'git',
  subCommands: { remote: remoteCommand }
})
```

### Command Resolution Logic

```typescript
// Consume positional arguments sequentially to traverse the tree
// argv: ["remote", "add", "--verbose"]
//   -> level 0: look up "remote" in subCommands -> found
//   -> level 1: look up "add" in remote.subCommands -> found
//   -> execute "add" command with remaining arguments
```

### Context Changes

```typescript
interface CommandContext<G> {
  // In addition to existing properties:
  commandPath: string[] // ['remote', 'add'] - the nested command path
  // callMode can be used as-is
}
```

### Renderer

```
$ git remote --help

USAGE:
  git remote [COMMANDS] <OPTIONS>

COMMANDS:
  add           Add a remote
  remove        Remove a remote

For more info, run any command with the `--help` flag:
  git remote add --help
  git remote remove --help
```

### Lazy Loading

```typescript
const remoteLazy = lazy(
  async () => {
    const { default: cmd } = await import('./commands/remote.ts')
    return cmd // cmd.subCommands contains nested commands
  },
  {
    name: 'remote',
    description: 'Manage remotes',
    // Declaring sub-commands as metadata upfront enables help display before loading the parent
    subCommands: {
      add: lazy(() => import('./commands/remote-add.ts'), {
        name: 'add',
        description: 'Add a remote'
      }),
      remove: lazy(() => import('./commands/remote-remove.ts'), {
        name: 'remove',
        description: 'Remove a remote'
      })
    }
  }
)
```

### Evaluation

| Aspect            | Assessment                                                                                                                                                                                                                                    |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Rendering**     | Each level owns its own `subCommands`, so the renderer can reuse the current logic almost as-is. `loadCommands` only needs to reference the target Command's `subCommands`                                                                    |
| **Lazy Loading**  | `subCommands` can be passed in `lazy()`'s second argument (definition), enabling help display before loading the parent. Sub-commands can also be overridden after the parent is loaded                                                       |
| **Plugin Compat** | i18n: Extend `resolveKey` to accept command paths (e.g., `resolveKey('description', 'remote/add')`). renderer: `loadCommands` simply targets the resolved command's `subCommands`. global: `--help`, `--version` work naturally at each level |
| **Performance**   | Tree traversal during resolution, but only one Map lookup per level, so O(depth). Lazy loading of child commands is only needed for help display                                                                                              |
| **Type Safety**   | Adding `subCommands` to `Command<G>` uses `SubCommandable` for loose type constraints. Type inference works naturally with nesting                                                                                                            |

### Pros

- Most intuitive API for users (commands owning child commands is natural)
- Supports nesting to arbitrary depth
- Each command is independent, making per-command testing easy
- Can coexist with the existing `subCommands` option in `CliOptions`

### Cons

- Requires changes to the `Command` interface (not breaking, but wide-reaching)
- `LazyCommand` also needs a `subCommands` property
- `cliCore()`'s command resolution logic needs to be changed to iterative/recursive
- Positional argument consumption logic becomes more complex (determining how many are command path vs. command arguments)

---

## Proposal B: Flat Path Registration (Path-based string keys)

### Overview

Keep the existing flat structure of the `subCommands` Map and represent nesting through path strings in the keys.

### User API

```typescript
await cli(process.argv.slice(2), entry, {
  name: 'git',
  subCommands: {
    remote: remoteCommand,
    'remote add': addCommand,
    'remote remove': removeCommand
  }
})
```

### Command Resolution Logic

```typescript
// Longest-prefix matching
// argv: ["remote", "add", "--verbose"]
//   -> look up "remote add" -> found -> consume 2 positionals
//   -> remaining: ["--verbose"]

function resolveNestedCommand(tokens: ArgToken[], subCommands: Map): ResolveCommandContext {
  const positionals = tokens.filter(t => t.kind === 'positional')
  // Try from the longest path (up to max depth)
  for (let depth = positionals.length; depth >= 1; depth--) {
    const path = positionals
      .slice(0, depth)
      .map(p => p.value)
      .join(' ')
    const cmd = subCommands.get(path)
    if (cmd) {
      return { commandName: path, command: cmd, callMode: 'subCommand', skipPositional: depth - 1 }
    }
  }
  // ... fallback
}
```

### Renderer

The renderer needs to virtually reconstruct a tree structure from path strings:

```typescript
// When displaying --help for 'remote':
// Filter subCommands for keys starting with 'remote ' -> show direct children
function getChildCommands(parentPath: string, subCommands: Map) {
  const prefix = parentPath + ' '
  return [...subCommands.entries()].filter(
    ([key]) => key.startsWith(prefix) && !key.slice(prefix.length).includes(' ')
  )
}
```

### Evaluation

| Aspect            | Assessment                                                                                                                               |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| **Rendering**     | Requires reconstructing a tree from the flat map, making rendering logic more complex                                                    |
| **Lazy Loading**  | Individual commands can be lazily loaded as before. However, lazy loading an entire group is difficult (all paths must be known upfront) |
| **Plugin Compat** | i18n: Path strings can be used directly as keys, which is relatively simple. renderer: Requires tree reconstruction as described above   |
| **Performance**   | Longest-prefix matching is O(depth x map_size), but not a practical concern                                                              |
| **Type Safety**   | String-key-based approach provides weak type inference                                                                                   |

### Pros

- Minimal structural changes to `CliOptions.subCommands`
- No changes to the `Command` interface
- Relatively simple implementation (flat map lookup only)
- Sufficient for shallow nesting

### Cons

- Redundancy of registering group commands (`remote`) and child commands (`remote add`) separately
- Rendering is complex due to the need to reconstruct tree structure from strings
- Lazy loading an entire sub-tree is difficult (child paths must be pre-registered even if the parent is lazy)
- Definition via `define()` / `lazy()` is separated from registration (no nesting information in the definition itself)
- Readability degrades with deep nesting

---

## Proposal C: CommandGroup (defineGroup) (New CommandGroup concept)

### Overview

Introduce a new `CommandGroup` concept without modifying the existing `Command`. A command group serves as a dedicated container for bundling sub-commands.

### User API

```typescript
import { defineGroup } from 'gunshi'

const remoteGroup = defineGroup({
  name: 'remote',
  description: 'Manage remotes',
  subCommands: {
    add: addCommand,
    remove: removeCommand
  },
  // Optional: execution function when no sub-command is specified
  run: () => console.log('Use: remote add|remove')
})

await cli(process.argv.slice(2), entry, {
  name: 'git',
  subCommands: { remote: remoteGroup }
})
```

### Type Definitions

```typescript
interface CommandGroup<G extends GunshiParamsConstraint = DefaultGunshiParams> {
  name: string
  description?: string
  subCommands: Record<string, SubCommandable> | Map<string, SubCommandable>
  run?: CommandRunner<G> // Execution function when sub-command is omitted
  args?: ExtractArgs<G> // Shared arguments for the group
}

// Extend SubCommandable to accept CommandGroup
type SubCommandable = Command | LazyCommand | CommandGroup | LazyCommandGroup

// Lazy version
const lazyRemote = lazyGroup(() => import('./commands/remote-group.ts'), {
  name: 'remote',
  description: 'Manage remotes'
})
```

### Command Resolution Logic

```typescript
function resolveCommand(tokens, entry, options) {
  const sub = getSubCommand(tokens)
  const cmd = options.subCommands.get(sub)

  if (isCommandGroup(cmd)) {
    // For groups, recursively resolve with the next positional
    const nextSub = getSubCommand(remainingTokens)
    return resolveCommand(remainingTokens, cmd, { subCommands: cmd.subCommands })
  }

  // For regular commands, proceed as usual
  return { commandName: sub, command: cmd, callMode: 'subCommand' }
}
```

### Evaluation

| Aspect            | Assessment                                                                                                                                               |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Rendering**     | Requires adding a rendering path for when a `CommandGroup` is detected. However, the structure is clear, so implementation is relatively straightforward |
| **Lazy Loading**  | Can be lazily loaded via `lazyGroup()`. Individual commands within the group can also be lazy                                                            |
| **Plugin Compat** | Requires adding `isCommandGroup()` guards to each plugin. Moderate impact on existing plugins                                                            |
| **Performance**   | Equivalent to Proposal A (tree traversal)                                                                                                                |
| **Type Safety**   | Having a dedicated `CommandGroup` type makes the distinction between groups and commands explicit                                                        |

### Pros

- No changes to the existing `Command` interface (backward compatibility)
- Clear semantic distinction between groups and commands
- Dedicated APIs (`defineGroup()` / `lazyGroup()`) make user intent explicit
- Recursive nesting is naturally expressible

### Cons

- Introduction of a new concept (learning cost)
- Need to choose between `Command` and `CommandGroup` (similar but distinct)
- Increased type definitions (`CommandGroup`, `LazyCommandGroup`, extended `SubCommandable`)
- `SubCommandable` type becomes more complex
- Refactoring needed when nesting is required later (`define` -> `defineGroup`)

---

## Comparison

| Aspect                        | A: Command Tree                              | B: Flat Path                              | C: CommandGroup                         |
| ----------------------------- | -------------------------------------------- | ----------------------------------------- | --------------------------------------- |
| **API Intuitiveness**         | ◎ Most intuitive                             | △ String paths are verbose                | ○ Explicit but somewhat heavy           |
| **Implementation Complexity** | ○ Moderate                                   | ◎ Simplest                                | △ New concept + additional types        |
| **Backward Compatibility**    | ○ `subCommands` is optional, so non-breaking | ◎ No existing API changes                 | ◎ Entirely additive                     |
| **Lazy Loading**              | ◎ Can lazily load entire sub-trees           | △ Difficult to lazily load sub-trees      | ○ Possible with `lazyGroup`             |
| **Rendering**                 | ◎ Naturally renders tree structures          | △ Requires tree reconstruction from paths | ○ Requires group detection logic        |
| **Plugin Compat**             | ○ Minor modifications to existing plugins    | ○ Minor modifications to existing plugins | △ Requires group support in each plugin |
| **Performance**               | ◎ O(depth) Map lookups                       | ○ Longest-prefix matching                 | ◎ O(depth) Map lookups                  |
| **Deep Nesting**              | ◎ Arbitrary depth                            | △ Paths become long                       | ◎ Arbitrary depth                       |

## Recommendation

**Proposal A (Command Tree)** provides the best balance. Reasons:

1. **Most natural user API** - Adding `subCommands` to `Command` is a natural extension of the current design where `CliOptions` already has `subCommands`, maintaining consistency
2. **Excellent lazy loading compatibility** - Passing `subCommands` in `lazy()`'s definition enables help display before loading the parent. Lazy loading entire sub-trees is also naturally achievable
3. **Minimal renderer changes** - The current `loadCommands()` mechanism only needs to be adjusted to look at the target command's `subCommands`
4. **Backward compatibility** - `Command.subCommands` is optional, so no existing code needs to change
5. **Performance** - Tree traversal is O(depth), which is not an issue for practical CLI nesting depths (2-3 levels)

Proposal C is conceptually clean, but the number of new types and functions is high, and all existing plugins would need `CommandGroup` support, making implementation costs significant. Proposal B is simple to implement, but has a critical limitation in that entire sub-trees cannot be lazily loaded.
