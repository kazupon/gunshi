# @bombshell-dev/tabを使用したplugin-completionの設計（修正版）

PluginContextのaddCommandを活用して、`complete`サブコマンドベースの補完サーバーを実装します。

## 1. プラグイン構造

```typescript
// packages/plugin-completion/src/index.ts
import { plugin, type PluginWithExtension } from '@gunshi/plugin'
import { Completion, script } from '@bombshell-dev/tab'
import type { Command, LazyCommand } from 'gunshi'

export interface CompletionCommandContext {
  // 補完インスタンスへのアクセス
  completion: Completion
  // カスタム補完ハンドラの登録
  registerHandler(commandPath: string[], handler: CompletionHandler): void
}

type CompletionHandler = (args: {
  previousArgs: string[]
  toComplete: string
  endsWithSpace: boolean
}) => Promise<Array<{ value: string; description?: string }>>
```

## 2. プラグイン実装

```typescript
export default function completion(): PluginWithExtension<CompletionCommandContext> {
  const completion = new Completion()
  const customHandlers = new Map<string, CompletionHandler>()

  return plugin({
    id: 'g:completion',
    name: 'completion',

    setup(ctx) {
      // 1. completeサブコマンドを追加（補完サーバー）
      ctx.addCommand('complete', {
        name: 'complete',
        description: 'Handle shell completions (internal use)',
        run: async cmdCtx => {
          // "--"以降の引数を取得
          const argsToComplete = cmdCtx.rest

          // @bombshell-dev/tabで補完を解析
          const results = await completion.parse(argsToComplete)

          // 結果を出力（シェルが読み取る形式）
          results.items.forEach(item => {
            console.log(item.value)
            if (item.description) {
              console.log(`:${item.description}`)
            }
          })

          // ディレクティブを出力
          console.log(`\n${results.directive}`)
        }
      })

      // 2. completionサブコマンドを追加（スクリプト生成）
      ctx.addCommand('completion', {
        name: 'completion',
        description: 'Generate shell completion script',
        args: {
          shell: {
            type: 'string',
            description: 'Target shell (bash|zsh|fish)',
            default: detectShell()
          }
        },
        run: async cmdCtx => {
          const shell = cmdCtx.values.shell as string
          const execName = cmdCtx.env.name || 'cli'
          const execPath = process.argv[1]

          // シェルスクリプトを生成
          const scripts = script(execName, execPath)

          if (!(shell in scripts)) {
            throw new Error(`Unsupported shell: ${shell}`)
          }

          cmdCtx.log(scripts[shell as keyof typeof scripts])
        }
      })
    },

    extension(ctx) {
      // 3. gunshiのコマンド構造を@bombshell-dev/tabに変換
      setupCompletions(completion, ctx.pluginContext, customHandlers)

      return {
        completion,
        registerHandler: (commandPath, handler) => {
          const key = commandPath.join(':')
          customHandlers.set(key, handler)
        }
      }
    }
  })
}
```

## 3. コマンド構造の変換

```typescript
function setupCompletions(
  completion: Completion,
  pluginContext: PluginContext,
  customHandlers: Map<string, CompletionHandler>
) {
  const subCommands = pluginContext.subCommands

  // ルートレベルの補完
  completion.addCommand('', 'Root command', async ({ toComplete, previousArgs }) => {
    // completeコマンド自体は補完候補から除外
    if (previousArgs.length === 0) {
      const commands = Array.from(subCommands.keys())
        .filter(cmd => cmd !== 'complete' && cmd !== 'completion')
        .filter(cmd => cmd.startsWith(toComplete))
        .map(cmd => ({
          value: cmd,
          description: subCommands.get(cmd)?.description
        }))

      return commands
    }

    return []
  })

  // 各サブコマンドの補完を設定
  for (const [name, command] of subCommands) {
    if (name === 'complete' || name === 'completion') continue

    setupCommandCompletion(completion, name, command, customHandlers)
  }

  // グローバルオプションの補完
  for (const [name, schema] of pluginContext.globalOptions) {
    completion.addOption('', `--${name}`, schema.description || '', async () => {
      return getValueCompletions(schema)
    })
  }
}

function setupCommandCompletion(
  completion: Completion,
  name: string,
  command: Command | LazyCommand,
  customHandlers: Map<string, CompletionHandler>
) {
  completion.addCommand(name, command.description || '', async args => {
    // カスタムハンドラがあれば使用
    const handler = customHandlers.get(name)
    if (handler) {
      return handler(args)
    }

    // デフォルトはオプションの補完
    return []
  })

  // コマンドのオプションを補完に追加
  if ('args' in command && command.args) {
    for (const [argName, argSchema] of Object.entries(command.args)) {
      completion.addOption(name, `--${argName}`, argSchema.description || '', async () => {
        return getValueCompletions(argSchema)
      })
    }
  }
}

function getValueCompletions(schema: any) {
  if (schema.type === 'boolean') {
    return [
      { value: 'true', description: 'Enable' },
      { value: 'false', description: 'Disable' }
    ]
  }

  if (schema.enum) {
    return schema.enum.map((value: string) => ({ value }))
  }

  return []
}
```

## 4. 使用例

```typescript
// ユーザーのCLIアプリケーション
import { cli } from 'gunshi'
import completion from '@gunshi/plugin-completion'

const comp = completion()

await cli(process.argv.slice(2), {
  name: 'my-cli',
  description: 'My CLI tool',
  plugins: [comp],
  subCommands: new Map([
    [
      'build',
      {
        description: 'Build the project',
        args: {
          target: {
            type: 'string',
            enum: ['dev', 'prod'],
            description: 'Build target'
          }
        },
        run: async ctx => {
          // カスタム補完を登録
          if (ctx.extensions['g:completion']) {
            ctx.extensions['g:completion'].registerHandler(['build'], async ({ toComplete }) => {
              // プロジェクトファイルから動的に補完候補を生成
              const projects = await getProjects()
              return projects
                .filter(p => p.startsWith(toComplete))
                .map(p => ({ value: p, description: 'Project' }))
            })
          }
        }
      }
    ]
  ])
})
```

## 5. シェルセットアップ

```bash
# 1. 補完スクリプトを生成
$ my-cli completion zsh > ~/.my-cli-completion.zsh

# 2. シェル設定に追加
$ echo 'source ~/.my-cli-completion.zsh' >> ~/.zshrc

# 3. 補完が動作
$ my-cli bu[TAB]
build -- Build the project

$ my-cli build --target [TAB]
dev  -- Development
prod -- Production
```

## 6. 内部動作フロー

1. ユーザーがTabキーを押す
2. シェルが`my-cli complete -- build --ta`を実行
3. gunshiが`complete`サブコマンドを実行
4. @bombshell-dev/tabのCompletionが引数を解析
5. 登録されたハンドラから補完候補を生成
6. 結果を標準出力に出力
7. シェルが補完候補を表示

この設計により、環境変数に依存せず、クリーンなサブコマンドベースの補完サーバーを実装できます。
